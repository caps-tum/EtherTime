
\section{Potential Failures}

Having an accurate clock synchronization across a network of machines can be just a nice-to-have for some applications, but applications that need to rely on the accuracy of the clock to perform their work need better guarantees than just an estimate of the accuracy.
Resilience is a top priority when building dependable systems, and to ensure that a system can operate reliably engineers will often add safety margins to their systems so that deviations in components of the system will not cause complete system failure.
In the context of time synchronization, since estimating the offset between clocks in software is imprecise even after applying denoising techniques, and the actual offset is influenced by a range of environmental conditions, the margin needs to be sufficiently large.
The high level of uncertainty combined with high risk, consequences of failure, and/or system criticality for certain application scenarios can merit safety factors of 5$\times$, 10$\times$ or beyond depending on the application scenario\todo{Would be nice to have something to cite here}.
Naturally, the exact factor varies between use-cases, but for the purpose of our analysis of determining what conditions can lead to failures, we choose a safety factor of an order of magnitude (10$\times$) over the baseline to be conservative, although actual deployments may require additional margin.
Thus, for our testbed of Raspberry Pis, a failure constitutes any time when the measured clock offset exceeds 40\,\textmu{}s\todo{Actually insert the baseline.}.

\subsection{Sources of Error}

Error can originate from 2 principal sources: either the clock fails to perform according to specifications, or PTP's ability to measure the difference between clock sources is degraded or disrupted entirely.

\paragraph*{Invariants of Timing Sources} Many of the assumptions made when using a clock are made implicitly because they seem natural in the real world, and a surprising number of software systems rely on them perhaps without being specifically aware of it. In order for a clock to be useful, it needs to fulfill all these invariants, ranked in decreasing order of importance:

\newcounter{errorConditions}
\begin{enumerate}[label=I\arabic*.]
    \item \textbf{Time flows forward.} This is perhaps the most important assumption, and the one with the worst consequences when it is violated. A clock that rewinds is not something that is well accounted for in software systems, and it can cause any number of cascading failures, with common ones including missed deadlines as well as data inconsistencies. Due to the problems associated with this, any amount of backward time shifting is considered a violation.
    \item \textbf{Time does not jump.} While systems expect time to pass, jumping too far into the future can cause e.g. load spikes through too many scheduled tasks arriving simultaneously or tasks being skipped entirely. To be compliant, gaps in time-keeping should be no larger than our designated bound.
    \item \textbf{Time passes at a constant rate.} While this might seem like the most important constraint, it is actually the easiest one to bend without compromising the usefulness of the clock. No process is perfect, thus tolerance is always expected, and software is designed to cope with some amount of variance in the flow of time.
    \setcounter{errorConditions}{\value{enumi}}
\end{enumerate}

Even during our experiments, which were carefully designed to account for the unreliable telling of time, we ran into issues with all of the above since PTP inevitably needs to violate (potentially all of) these assumptions to synchronize the clocks when there is a difference. Correcting for this error is difficult when there is no second source of time to cross-validate with, which is why we eventually used an external time source for record-keeping. Generally, PTP tries to minimize disruptions by breaking the lowest priority invariant possible to keep clocks in sync, exploiting the fact that I3 is more of a soft requirement.

\paragraph*{Multiple Sources of Time}

When two or more clocks are at play, then another invariant arises:

\begin{enumerate}[label=I\arabic*.]
    \setcounter{enumi}{\value{errorConditions}}
    \item \textbf{Coherence between ordered readings of different clocks.} A reading of one clock that comes before another should always yield a timestamp smaller than the latter to allow comparing them to be useful. This is equivalent with obtaining the same timestamp when reading both clocks simultaneously, but this is not possible in practice. Since this condition cannot be perfectly fulfilled, we only consider the coherency to be violated when the order is not preserved even though the readings were further apart than the tolerance bound.
\end{enumerate}

Establishing and maintaining coherency is PTP's primary purpose, and maintaining I4 does not have a fixed priority, it sometimes merits breaking I2 or even I1. However, for synchronization to be possible two preconditions need to be fulfilled. These are the two principal challenges that PTP is faced with:

\begin{enumerate}[label=P\arabic*.]
%    \setcounter{enumi}{\value{errorConditions}}

    \item \textbf{Clock difference can be measured.} The prerequisite to synchronizing two clocks is to be able to quantify the offset, which is difficult to do reliably across packet-switched networks with best-effort quality of service.
    \item \textbf{Clock difference can be corrected.} Even when a difference can be measured it does not automatically imply that it can be corrected. Modifying current time directly violates conditions I1-I3, so time synchronization programs frequently have rules in place limiting when which conditions may be violated.
\end{enumerate}

In order for two clocks to stay synchronized, both conditions need to be continuously fulfilled to prevent divergence from occurring, which would cause invariant I4 to break down.

\subsection{Potential Consequences}\todo{better heading}
A violation of any of these conditions is an error in the timing system that can propagate throughout the entire system.
In the case of the first three clock invariants, failures will cause local incoherence, potentially triggering cascading failure even in system components that do not interact across a network. On the other hand, problems with time synchronization prerequisites causes clocks to diverge (I4), which only becomes noticeable upon communication when the coherency breaks down.
While this might seem less troublesome, the entire point of deploying PTP is to provide reliable and high accuracy time synchronization, so a failure to provide this invalidates the usefulness of PTP itself.

Throughout this study, we will determine what can be expected of PTP, when and under what conditions the invariants and prerequisites inevitably break down under adverse conditions, and what this means for the ability of applications to reliably leverage Ethernet-based time synchronization.
%\todo{Explicitly list what our 10x bound means for each invariant.}

\begin{table}
    \centering
    \caption{Conditions that constitute a violation of the time source invariants, as per the defined 10$\times$ safety margin above the baseline.}
    \begin{tabular}{crr}
        Invariant & Raspberry-Pi& 2nd System\\
        I1 & $\Delta{}t<0$& \\
        I2& $\Delta{}t>40$\textmu{}s& \\
        I3& --& \\
        I4& $|t_{C1} - t_{C2}| > 40$\textmu{}s& \\
    \end{tabular}
    \label{tbl:invariant-violation-limits}
\end{table}
