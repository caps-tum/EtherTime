
%\section{Methodology}

\subsection{Testbed -- Hardware and Software}

To conduct our evaluation we employ two hardware testbeds: A cluster consisting of three Raspberry Pi 4 attached to an isolated wired Ethernet network via a single Gigabit Ethernet switch and a second cluster consisting of three Raspberry Pi 5 in the same hardware layout. There are two key differences relevant to timekeeping between the Raspberry-Pi 4 and the Raspberry-Pi 5: The Raspberry-Pi 5 has support for PTP hardware timestamping on the network interface, and it has an integrated real-time clock (RTC) that can be powered by an external battery, both of which the Raspberry-Pi 4 lacks. This selection of hardware is representative of the range of embedded systems/edge devices available, which may or may not include these hardware features that we expect to provide benefits to the synchronization quality. Both clusters are controlled by a programmable power delivery unit so that we can simulate hardware failures in each component individually.

We have selected four vendors for behavioral analysis: PTPd, LinuxPTP, SPTP and Chrony. PTPd is a traditional implementation of the PTP protocol, that despite being less maintained in recent years~\cite{ptpd-maintainers} and lacking modern features such as hardware timestamping~\cite{ptpd-manpage}, it spawned a variety of forks and is still being deployed according to the Debian package tracker~\cite{debian-popularity-contest}, perhaps due to its relative simplicity and wider support of non-Linux UNIX systems. LinuxPTP is the most deployed~\cite{debian-popularity-contest} open-source solution on Debian, with the stated goals of providing robustness while taking advantage of the kernel features provided by Linux~\cite{linuxptp-homepage}. SPTP, a very young time-synchronization protocol, server, and client, developed by Meta due to difficulties they encountered with deploying PTP, claims to offer a comparable level of time-synchronization performance while offering lower resource consumption and better resilience~\cite{facebook-sptp}. Finally, Chrony is included as a reference representing the state of the art implementation of the Network Time Protocol (NTP)\todo{cite}. It is by far the most feature-complete time-synchronization implementation of the ones we evaluated and is far more widely deployed than PTP~\cite{debian-popularity-contest}, likely due to its applicability to wide area networks. It serves as a baseline for the other implementations.

\subsection{PTP Lifecycle}


\begin{figure*}
    \newcommand{\intervalAnnotation}[4]{
        \draw[Bar-Bar] ([yshift=#3, xshift=-0.1cm]#1.south west) -- ([yshift=#3, xshift=0.1cm]#2.south east) node[midway, below] {#4};
    }
    \newcommand{\intervalAnnotationAbove}[4]{
            \draw[Bar-Bar] ([yshift=#3, xshift=-0.1cm]#1.north west) -- ([yshift=#3, xshift=0.1cm]#2.north east) node[midway, above] {#4};
    }

    \begin{tikzpicture}[
        start chain=stages going right,
        stage/.style={
            draw, on chain=stages,
            every on chain/.style={join}, every join/.style={-Stealth}
        },
        text depth=0cm,
        ]
        \node[stage] (discovery) {Discovery};
        \node[stage] (bmca) {Best Master Clock Algorithm};
        \node[stage] (calibrate) {Calibration};
        \node[stage] (step) {Clock Step};
        \node[stage] (slew) {Clock Slew};
        \node[stage] (maintain) {Stable};

        \intervalAnnotation{step}{slew}{-0.25cm}{Converging}
        \intervalAnnotation{maintain}{maintain}{-0.25cm}{Synchronized}
        \intervalAnnotationAbove{calibrate}{maintain}{0.25cm}{Slave bound to Grandmaster}
        \intervalAnnotationAbove{discovery}{bmca}{0.25cm}{Peer}

    \end{tikzpicture}
    \caption{Different stages in the PTP lifecycle that a PTP slave traverses while synchronizing its clock. }
    \label{fig:ptp-lifecycle}
\end{figure*}

PTP clients traverse multiple stages in a lifecycle to synchronize their clock (Figure~\ref{fig:ptp-lifecycle}). At any point, unexpected conditions such as loss of connectivity can lead PTP to return to an earlier stage in the lifecycle, potentially changing the operating conditions.

\begin{enumerate}[label=S\arabic*.]
    \item \textbf{Discovery} is the stage where remote clocks are identified, usually via periodic multicast announcements. Discovered clients are collected into a PTP domain.
    \item \textbf{Best Master Clock Algorithm (BMCA)} is the predefined algorithm used for each peer to determine whether it should become a master clock or a slave, which can be configured using priorities and clock properties~\cite{bmca-deep-dive}. By the end of this phase, each peer will become either a master clock or a slave. Slaves proceed to connect to, and negotiate with, the master clock.
    \item \textbf{Calibration} is a brief phase where no local clock modifications are made yet to allow the estimate of the offset to increase in precision through multiple synchronization intervals and path delay estimates.
    \item \textbf{Clock Step} Having arrived at a reasonably precise estimate of the offset, an attempt is made to immediately rectify the offset by directly resetting the slave's local time. Since this is a direct violation of invariants I2 and potentially I1 and since this is expected to break applications, it is only done when the offset is large (e.g.~$>1$~second) and PTP profiles usually allow this to happen only once during the initial synchronization where only using clock-slew would take too long.
    \item \textbf{Clock Slew} is the second phase of convergence where time is made to pass slightly slower or slightly quicker via kernel parameters to fine-tune the clocks position, thus further reducing offset. The rate of change is usually limited via software and configuration parameters, e.g. the Linux kernel limits the rate of change to 500 parts per million, equivalent to 0.05\%~\cite{adjtimex}. These limits ensure that the clock signal does not drift too rapidly, but can make convergence slow -- the 0.05\% limit implies that correcting 1 second of offset takes at least 33 minutes.
    \item \textbf{Stable} is the phase where the clock offset cannot be reduced further, and therefore the clocks are as synchronized as they can get. In this phase, further clock slew is happening to correct clock frequency differences and slight variations still occur due to lack of offset estimation precision, but at this point the clock signal is the most stable and most useful.
\end{enumerate}