
\section{Introduction}
%\todo{From last discussion: Diagram showing Testbed setup (including Database)}
%\todo{From last discussion: Short section explaining what \toolName{} is}
%\todo{Find places to insert the word ``real-time'' to solidify applicability to RTSS.}

%``Time is of the essence'', to many readers this might only be an idiom but the relevance of time throughout our daily lives, processes and systems is so ubiquitous that we frequently fail to appreciate its significance. While the phrase is said to have originated from the legal domain, time-criticality and the necessity of having a common notion of time permeates all sectors, from logistics and manufacturing in industry, to service-level objectives in service providers, emergency response in public healthcare systems, activities in people's day-to-day routines, and even to academia, as everybody perpetually works towards the next deadline. In computer systems and communications, time has been with us from the very beginnings, with its significance showing from the most basic synchronized digital circuits even to places where one might not expect, such as in the world's most pervasive digital cryptography deployment, the SSL/TLS PKI~\cite{ssl-client-warnings}.

%Time is both ubiquitous and critical.
%, no computer system today can run without it.
With the availability of the internet, satellite communications, and digital clocks, we take for granted that we can tell accurate time anywhere and anytime.
%
%Nowadays, with the availability of the internet, satellite communications and digital clocks, we often take for granted that we can tell the time anywhere and anytime. And for most human use cases, a rough estimate of the current time on the order of magnitude of seconds is perfectly sufficient.
%After all, sub-second granularity is irrelevant as people follow their daily schedules, and for project plans that span years or even decades a day or two more will not make a difference. \todo{colloquial/irrelevant}
However, in communications, real-time systems, and circuitry, we operate on a scale where things are not so simple,
with sub-nanosecond-level accuracies gaining significance in areas such as networks and chip design~\cite{nanopu,sub-nanosecond-comms-design}.
Precision time (clock) synchronization thus plays a key role in modern computing systems.

A classical application enabled by precision time synchronization
is Global Navigation Satellite System~\cite{intro-to-gnss},
which is often used as a nanoscale clock source itself for high-quality location estimates
\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing}.
%Global Navigation Satellite Systems (GNNS), a classical application enabled by precision time-synchronization, relies on signal propagation delays to determine relative positioning~\cite{intro-to-gnss}.
%High-quality location estimates hinge on accurate timing and -compensation mechanisms, so GNSS is frequently leveraged as a nanoscale clock source~\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing}.
%Failure to compensate clock differences or even the presence of adversarial signals can quickly degrade the resulting location quality~\cite{gps-jamming}, but in general GNNS systems enjoy widespread popularity not only as a way of acquiring location estimates but also as a way of obtaining highly accurate estimates of time~\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing}.
%but the precision incurs expense though; it requires dedicated hardware, strains limited power budgets, and inhibits indoor deployments.
%
%Precision time synchronization nonetheless remains ubiquitous and critical.
%
%, no computer system today can run without it.
%Timing is also critical for distributed systems
In datacenter and high-performance computing,
a common notion of time enables effective profiling and optimization of distributed systems.
%which allows maximizing hardware utilization~\cite{hpc-understanding-bottlenecks, hpc-solving-io-bottleneck, hpc-diagnosing-io-bottlenecks}\todo{Source that refers to clock synchronization for HPC profiling}.
For example, Google and Facebook use precision time synchronization to ensure transaction ordering across a distributed system without an application having to explicitly synchronize~\cite{corbett2013spanner,li2020sundial,ouellete2023precision}.
These techniques also transfer to edge computing, as they allow applications to achieve more with less hardware~\cite{chen2021achieving, wang2019frame}.
Even large scale deployments cannot function without coordinated timing, with the internet (SSL/TLS cryptographic certificate validation~\cite{ssl-client-warnings}), broadcast media (audio/video synchronization~\cite{time-synchronization-for-multimedia}), science (telescopes, large hadron colliders and radar~\cite{white-rabbit-astrophysics,white-rabbit-at-cern, time-synchronization-radar}) and industry (automotive and factory floor~\cite{time-synchronization-automotive,time-synchronization-factory-floor}) all relying on it.

%The primary motivation for this study is fault-tolerant real-time systems.
%, for which timing is often absolutely critical.
Precise synchronization is also critical for fault-tolerant real-time systems.
Fault-tolerant architectures with double- or triple-modular lock-step redundancy~\cite{triple-modular-redundancy,triple-modular-redundancy-evaluation,triple-modular-lock-step-arm}
%where algorithms are run independently on different machines to automatically detect and correct errors,
rely on a common notion of time and deadlines to make progress even when a machine has failed.
Such systems are routinely used in high-reliability and high-availability applications with strict timing requirements, such as aviation.
Similar designs are being proposed for commercial off-the-shelf (COTS) platforms~\cite{gujarati2022concretes,gandhi2021rebound,loveless2021igor} to improve the fault tolerance of consumer cyber-physical systems, such as robots and unmanned vehicles.
%Failed safety-critical redundancy engineering has seen some infamous examples recently, with deadly Boeing 737-Max incidents prompting the introduction of new laws for flight control computer error resilience~\cite{boeing-requirements}\todo{better citation}.
%\todo{@Arpan I removed the example, it's too much for the intro.}
Without reliable time synchronization, it is impossible for these systems to judge internally missed deadlines correctly, thus preventing proper error-detection and correction, voiding the fault-tolerance they were designed for.

%However, time is not only critical in fault-tolerant systems, it pervades all distributed systems.
%High-performance and datacenter computing are areas large amounts of resources are being spent on maximizing hardware utilization by reducing I/O or communications bottlenecks~\cite{hpc-understanding-bottlenecks, hpc-solving-io-bottleneck, hpc-diagnosing-io-bottlenecks}, and a common notion of time is a prerequisite enabling technology to effective profiling and optimization on distributed systems.
%%The better the time source, the easier it becomes to perform efficient handovers by precise scheduling, thus improving overall performance and resource consumption.
%Google and Facebook\todo{cite} have come up with time synchronization implementations based on the notion of windows of uncertainty that can be used to ensure transaction ordering across a distributed system without an application having to explicitly synchronize, a property useful not only to databases but also to real-time control, fault detection/mitigation and parallel data structures.
%Time synchronization techniques also transfer to edge computing, where scheduling computation and communication to efficiently manage load can conserve power and connectivity resources, allowing applications to achieve more with less hardware.
%Even large scale deployments like the internet cannot function without timing, as SSL/TLS cryptographic certificate validation, renewal of leases (DHCP) and caches (DNS, HTTP), and various other state machines built into systems and protocols (TCP, firewalls, etc.) all rely on clocks to function.

\textbf{This work.}
Out primary motivation is applications of precision time synchronization in real-time computing.
Specifically, we ask, to what degree can we truly rely on implementations of precision time synchronization protocols
when building next-generation distributed real-time systems? % where failures affect correctness?

%Modern deployments are not only characterized by dependability/redundancy
%requirements and resource constraints,
%but also increasingly rely on commodity processors and networks,
%which sets them apart from traditional architectures with custom hardware solutions~\cite{wensley1978sift,hopkins1978ftmp}.
%In addition, industrial and embedded applications are often relatively isolated from the internet,
%This sets them apart from typical timekeeping scenarios where an external source
%(wall-clock time) is used as ground truth
%In industrial and embedded computing,
These deployments %of distributed real-time systems
are often %will be %often
characterized by dependability/redundancy requirements,
the need to conserve all types of resources to reduce costs,
relative isolation from the internet, %regarding connectivity.
and increasing reliance on COTS hardware.
This sets them apart from typical timekeeping scenarios where an external source
(wall-clock time) is used as ground truth
and from traditional architectures with custom time synchronization hardware~\cite{wensley1978sift,hopkins1978ftmp}.
\change{There is also a lack of literature collecting empirical findings
across implementations and protocols, with an early study~\cite{ntp-vs-ptp} from 2006
and more recent studies~\cite{time-enough} not incorporating fault tolerance as a central aspect.}

We thus extensively study how well-known time synchronization protocols perform
on commodity embedded processors and networks and what causes them to break.
%showing their strengths and weaknesses in a variety of configurations.
Specifically, we offer the following main contributions.

\textbf{(1)}~We develop \toolName{}, an open-source tool\footnote{\toolName{} is available anonymously here: \url{https://anonymous.4open.science/r/ethertime-EBBF}.}, for fair and comparable cross-vendor evaluation of multiple time synchronization protocols and implementations.

\textbf{(2)}~We evaluate %the performance and resilience of
four implementations of prevalent Ethernet time synchronization protocols, % \todo{@Arpan Ethernet is always packet-switched, this might be confusing.},
including the Precision Time Protocol (PTP)~\cite{ptp-spec} and Network Time Protocol (NTP)~\cite{ntpv4-spec},
across four distinct hardware testbeds
based on two generations of Raspberry Pis,
Xilinx AVNet, and NVIDIA Jetson TK-1 boards (see \cref{tab:vendors,tbl:hardware_testbeds} for an overview).

\textbf{(3)}~For each configuration,
we present the baseline performance, % (without faults and contention),
performance under resource contention and with fault injection,
and resource consumption and scalability results.
%as well as fault tolerance,
%experiments showing if the synchronization is resilient against adverse
%conditions and faults,
%possibilities of mitigating the risk of synchronization failure,
%and assessment of deployability/resource consumption on embedded platforms.

\textbf{(4)}~We discuss the lessons learned and recommend best practices
for configuring precision time synchronization in highly reliable and
available COTS embedded systems.

%\todo{Link to Table 1}
%\todo{Create Table 2: Hardware Testbeds}

To the best of our knowledge,
\toolName{} is the first data collection and
analysis tool %available open-source\todo{anonymize}
for empirical evaluation of multiple Ethernet-based time
synchronization protocols and implementations across several embedded
platforms with an explicit focus on dependability and fault tolerance.

Overall, we find that precision time synchronization today is far from being
a reliable primitive,
especially when it comes to developing distributed real-time applications on
commodity processors and networks.
Many critical challenges need to be addressed,
which our study identifies in detail.

%\todo{Should results really go into the intro rather than the abstract or conclusion?}Overall, we find that Chrony is the most well-rounded system, with competitive
%synchronization accuracy, resilience and resource efficiency, while both
%LinuxPTP and SPTP offer synchronization accuracy but exhibit stability problems
%or require more resources to run. PTPd, which despite its age is still being
%deployed, shows shortcomings in synchronization accuracy due to the lack of
%support for modern hardware features. The most capable hardware platform
%evaluated is the Raspberry-Pi 5, both due to hardware timestamping support and
%importantly because of the real-time clock, which helps with fault-tolerance.
%However, critical challenges remain for maintaining accurate clock synchronization,
%including resource contention (specifically network and memory, CPU is less of an
%issue) and faults on the master node when the master node lacks a real-time
%clock. These need to be addressed before
%high-precision network time can truly be relied upon.

%\begin{itemize}
%    \item \toolName{}, an open-source tool for fair and comparable cross-vendor evaluation of multiple time synchronization protocols and implementations,
%    \item Establishment of a baseline of observed time-synchronization performance on several hardware testbeds across four vendors,
%    \item Evaluation of synchronization resilience against adverse conditions/faults and possibilities of mitigating risk of synchronization failure,
%    \item Assessment of deployability/resource consumption on embedded platforms,
%    \item Provide lessons-learned and best practices for configuring time-synchronization deployments for high reliability and availability.
%\end{itemize}


%We also make the data collection and analysis tooling available open-source\todo{anonymize} to enable future studies to generate comparable results.
%
%The rest of this paper is structured into the following sections: Section~\ref{sec:background} covers time synchronization and PTP background, as well as related work, while Section~\ref{sec:failure_scenarios} looks at potential failure scenarios. Results are presented in Sections~\ref{sec:baseline} Baseline, \ref{sec:resource_contention} Resource Contention, \ref{sec:fault_tolerance} Fault Tolerance and \ref{sec:resource_consumption} Resource Consumption. Finally, we present some lessons learned and best practices in Section~\ref{sec:learnings_conclusion}.

%The remainder of the paper is structured as follows.
%\textbf{Paper organization.}
We start by summarizing the protocols surveyed and evaluated in this study (\cref{sec:protocols})
and the embedded platforms used for evaluation, including an overview of our testbed and our profiling tool \toolName{} (\cref{sec:testbed}).
We then provide a brief overview of PTP and identify common invariants and failure scenarios (\cref{sec:ptp-overview}).
We split the measurement study into to four parts:
baseline, % (\cref{sec:baseline},
resource contention, % (\cref{sec:resource_contention}),
fault tolerance, % (\cref{sec:fault_tolerance}),
and resource consumption experiments (\cref{sec:baseline} to \cref{sec:resource_consumption}, respectively).
Finally, we provide the key takeaways and lessons learnt,
%from this measurement study, % (\cref{sec:learnings_conclusion}),
related work, % (\cref{sec:related}),
and conclusion
(\cref{sec:learnings_conclusion} to \cref{sec:conclusion}, respectively).
