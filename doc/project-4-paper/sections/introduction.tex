
\section{Introduction}
\todo{From last discussion: Diagram showing Testbed setup (including Database)}
\todo{From last discussion: Short section explaining what PTP-Perf is}
\todo{Find places to insert the word ``real-time'' to solidify applicability to RTSS.}

%``Time is of the essence'', to many readers this might only be an idiom but the relevance of time throughout our daily lives, processes and systems is so ubiquitous that we frequently fail to appreciate its significance. While the phrase is said to have originated from the legal domain, time-criticality and the necessity of having a common notion of time permeates all sectors, from logistics and manufacturing in industry, to service-level objectives in service providers, emergency response in public healthcare systems, activities in people's day-to-day routines, and even to academia, as everybody perpetually works towards the next deadline. In computer systems and communications, time has been with us from the very beginnings, with its significance showing from the most basic synchronized digital circuits even to places where one might not expect, such as in the world's most pervasive digital cryptography deployment, the SSL/TLS PKI~\cite{ssl-client-warnings}.

%Time is both ubiquitous and critical.
%, no computer system today can run without it.
With the availability of the internet, satellite communications, and digital clocks, we take for granted that we can tell accurate time anywhere and anytime.
%
%Nowadays, with the availability of the internet, satellite communications and digital clocks, we often take for granted that we can tell the time anywhere and anytime. And for most human use cases, a rough estimate of the current time on the order of magnitude of seconds is perfectly sufficient.
%After all, sub-second granularity is irrelevant as people follow their daily schedules, and for project plans that span years or even decades a day or two more will not make a difference. \todo{colloquial/irrelevant}
However, in communications, real-time systems, and circuitry, we operate on a scale where things are not so simple,
with sub-nanosecond-level accuracies gaining significance in areas such as networks and chip design~\cite{nanopu,sub-nanosecond-comms-design}.
Precision time (clock) synchronization thus plays a key role in modern computing systems.

A classical application enabled by precision time synchronization 
is Global Navigation Satellite Systems~\cite{intro-to-gnss}.
It is often used as a nanoscale clock source itself %for high-quality location estimates
\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing},
%Global Navigation Satellite Systems (GNNS), a classical application enabled by precision time-synchronization, relies on signal propagation delays to determine relative positioning~\cite{intro-to-gnss}.
%High-quality location estimates hinge on accurate timing and -compensation mechanisms, so GNSS is frequently leveraged as a nanoscale clock source~\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing}.
%Failure to compensate clock differences or even the presence of adversarial signals can quickly degrade the resulting location quality~\cite{gps-jamming}, but in general GNNS systems enjoy widespread popularity not only as a way of acquiring location estimates but also as a way of obtaining highly accurate estimates of time~\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing}.
but the precision incurs expense though; it requires dedicated hardware, strains limited power budgets, and inhibits indoor deployments.

Precision time synchronization nonetheless remains both ubiquitous and critical.
%, no computer system today can run without it.
%Timing is also critical for distributed systems
In datacenter and high-performance computing,
a common notion of time enables effective profiling and optimization of distributed systems,
which allows maximizing hardware utilization~\cite{hpc-understanding-bottlenecks, hpc-solving-io-bottleneck, hpc-diagnosing-io-bottlenecks}.
For example, Google and Facebook use precision time synchronization to ensure transaction ordering across a distributed system without an application having to explicitly synchronize~\cite{corbett2013spanner,li2020sundial,ouellete2023precision}.
These techniques also transfer to edge computing, as they allow applications to achieve more with less hardware~\cite{chen2021achieving, wang2019frame}.
Even large scale deployments like the internet cannot function without coordinate timing,
e.g., SSL/TLS cryptographic certificate validation, renewal of leases (DHCP) and caches (DNS, HTTP), and various state machines built into TCP and firewalls all rely on global clocks~\cite{TODO}.

The primary motivation for this study is fault-tolerant real-time systems.
%, for which timing is often absolutely critical.
%Timing is often absolutely critical for fault-tolerant systems.
Architectures with double- or triple-modular lock-step redundancy~\cite{triple-modular-redundancy,triple-modular-redundancy-evaluation,triple-modular-lock-step-arm}
%where algorithms are run independently on different machines to automatically detect and correct errors,
rely on a common notion of time and deadlines to make progress even when a machine has failed.
Such systems are routinely used in high-reliability and high-availability applications with strict timing requirements, such as aviation.
Similar designs are being proposed for commercial off-the-shelf (COTS) platforms~\cite{gujarati2022concretes,gandhi2021rebound,loveless2021igor} to improve the fault tolerance of consumer cyber-physical systems, such as robots and unmanned vehicles.
%Failed safety-critical redundancy engineering has seen some infamous examples recently, with deadly Boeing 737-Max incidents prompting the introduction of new laws for flight control computer error resilience~\cite{boeing-requirements}\todo{better citation}.
\todo{@Arpan I removed the example, it's too much for the intro.}
Without reliable time synchronization, it is impossible for these systems to judge internally missed deadlines correctly, thus preventing them from providing proper error-detection and correction, voiding the fault-tolerance they were designed for.

%However, time is not only critical in fault-tolerant systems, it pervades all distributed systems.
%High-performance and datacenter computing are areas large amounts of resources are being spent on maximizing hardware utilization by reducing I/O or communications bottlenecks~\cite{hpc-understanding-bottlenecks, hpc-solving-io-bottleneck, hpc-diagnosing-io-bottlenecks}, and a common notion of time is a prerequisite enabling technology to effective profiling and optimization on distributed systems.
%%The better the time source, the easier it becomes to perform efficient handovers by precise scheduling, thus improving overall performance and resource consumption.
%Google and Facebook\todo{cite} have come up with time synchronization implementations based on the notion of windows of uncertainty that can be used to ensure transaction ordering across a distributed system without an application having to explicitly synchronize, a property useful not only to databases but also to real-time control, fault detection/mitigation and parallel data structures.
%Time synchronization techniques also transfer to edge computing, where scheduling computation and communication to efficiently manage load can conserve power and connectivity resources, allowing applications to achieve more with less hardware.
%Even large scale deployments like the internet cannot function without timing, as SSL/TLS cryptographic certificate validation, renewal of leases (DHCP) and caches (DNS, HTTP), and various other state machines built into systems and protocols (TCP, firewalls, etc.) all rely on clocks to function.

\textbf{This work.}
To what degree can we truly rely on modern computer timekeeping in distributed embedded systems where failures affect correctness?
In industrial and embedded computing,
deployments are often characterized by dependability/redundancy requirements,
the need to conserve all types of resources to reduce costs,
relative isolation from the internet, %regarding connectivity.
and increasing reliance on COTS processors.
This sets them apart from typical timekeeping scenarios where an external source
(wall-clock time) is used as ground truth
and from traditional architectures with custom hardware~\cite{wensley1978sift,hopkins1978ftmp}.
We thus extensively study how well-known time synchronization protocols perform on COTS devices and what causes them to break,
showing their strengths and weaknesses in a variety of configurations.
We offer the following contributions.

\textbf{(1)}~We develop PTP-Perf, an open-source tool\footnote{PTP-Perf will be made publicly available upon acceptance.}, for fair and comparable cross-vendor evaluation of multiple time synchronization protocols and implementations.

\textbf{(2)}~We evaluate %the performance and resilience of
four implementations of prevalent time synchronization protocols for packet-switched Ethernet,
specifically Precision Time Protocol (PTP)~\cite{ptp-spec} and Network Time Protocol (NTP)~\cite{ntpv4-spec},
across four distinct hardware testbeds
based on two generations of Raspberry-Pis~\cite{??, ??},
Xilinx AVNet~\cite{??}, and NVIDIA Jetson TK-1~\cite{??}.

\textbf{(3)}~For each configuration,
we present the baseline performance, % (without faults and contention),
experiments showing if the synchronization is resilient against adverse
conditions and faults,
possibilities of mitigating the risk of synchronization failure,
and assessment of deployability/resource consumption on embedded platforms.

\textbf{(4)}~We discuss the lessons learned, best practices, and recommendations
for configuring time-synchronization deployments for high reliability and availability.

%\begin{itemize}
%    \item PTP-Perf, an open-source tool for fair and comparable cross-vendor evaluation of multiple time synchronization protocols and implementations,
%    \item Establishment of a baseline of observed time-synchronization performance on several hardware testbeds across four vendors,
%    \item Evaluation of synchronization resilience against adverse conditions/faults and possibilities of mitigating risk of synchronization failure,
%    \item Assessment of deployability/resource consumption on embedded platforms,
%    \item Provide lessons-learned and best practices for configuring time-synchronization deployments for high reliability and availability.
%\end{itemize}

To the best of our knowledge, PTP-Perf is the first data collection and
analysis tool %available open-source\todo{anonymize}
that supports the empirical evaluation of multiple Ethernet-based time
synchronization protocols and implementations across several embedded hardware
testbeds with an explicit focus on reliability. %dependability and fault-tolerance.

%We also make the data collection and analysis tooling available open-source\todo{anonymize} to enable future studies to generate comparable results.
%
%The rest of this paper is structured into the following sections: Section~\ref{sec:background} covers time synchronization and PTP background, as well as related work, while Section~\ref{sec:failure_scenarios} looks at potential failure scenarios. Results are presented in Sections~\ref{sec:baseline} Baseline, \ref{sec:resource_contention} Resource Contention, \ref{sec:fault_tolerance} Fault Tolerance and \ref{sec:resource_consumption} Resource Consumption. Finally, we present some lessons learned and best practices in Section~\ref{sec:learnings_conclusion}.
