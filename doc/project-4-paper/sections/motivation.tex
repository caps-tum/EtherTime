
\section{Applications that Require Time}
A classical example of an application that requires precise notions of time is geolocation. GPS and related technologies rely on signal propagation delays to determine relative positioning [cite], and the time difference between clock sources (i.e. the satellites) needs to be precisely compensated so that delay differences can be measured accurately, thus leading to a high-quality location estimation. Failure to compensate clock differences or even the presence of adversarial signals can quickly degrade the resulting location quality.

Timing is also critical for fault-tolerant systems. Architectures such as double- or triple-modular lock-step redundancy, where algorithms are run independently on different machines to automatically detect and correct errors, rely on a common notion of time to make progress even when a machine has failed [cite]. Such systems are found frequently in high-reliability and -availability applications such as aviation, where computer systems are relied on for controlling machinery with strict timing requirements. Failed safety-critical redundancy engineering has seen some infamous examples recently, with deadly Boeing 737-Max incidents prompting the introduction of new laws for flight control computer error resilience [cite]. Without a common notion of time, it would not be possible for resilient systems to judge internally missed deadlines correctly, thus preventing the system from providing proper error-detection and correction, voiding the fault-tolerance it was designed for.

However, time is not only critical in fault-tolerant systems, it pervades all distributed systems. High-performance and datacenter computing are areas where millions are being spent on maximizing hardware utilization by reducing idling due to I/O, and a common notion of time across systems and components is both essential to quantifying the problem and mitigating it by optimizing synchronization. The better the time source, the easier it becomes to perform efficient handovers by reducing the chance of early or late arrival, thus improving overall performance and resource savings.
Edge computing can conserve usage of scarce resources, such as power or connectivity, by scheduling computation and communication to efficiently manage load, allowing applications to achieve more with less hardware.
\todo{Now improved: Weak example.}

Clearly, having some sort of clock synchronization is essential in almost all aspects of computing, and the range of accuracies required can be rather large. This makes it necessary to examine what our systems are capable of and what sort of reliability guarantees they can provide for our algorithms to work with.

\todo{Need a part here on what we are actually doing.}
\todo{Dependable embedded systems.}