
\section{Applications that Require Time}
\label{sec:motivation}

A classical example of an application that requires precise notions of time is geolocation. GPS and related Global Navigation Satellite Systems (GNNS) technologies rely on signal propagation delays to determine relative positioning~\cite{intro-to-gnss}, and the time difference between clock sources (i.e. the satellites) needs to be precisely compensated so that delay differences can be measured accurately, thus leading to a high-quality location estimation. Failure to compensate clock differences or even the presence of adversarial signals can quickly degrade the resulting location quality~\cite{gps-jamming}, but in general GNNS systems enjoy widespread popularity not only as a way of acquiring location estimates but also as a way of obtaining highly accurate estimates of time~\cite{gnss-location-and-time-advances,gnss-for-high-precision-timing}. However, using GNSS for time synchronization can be an expensive proposition, it requires dedicated hardware, cuts into an often limited power budget, and has the usual limitations regarding indoor deployment.

Timing is also critical for fault-tolerant systems. Architectures such as double- or triple-modular lock-step redundancy~\cite{triple-modular-redundancy,triple-modular-redundancy-evaluation,triple-modular-lock-step-arm}, where algorithms are run independently on different machines to automatically detect and correct errors, rely on a common notion of time and deadlines to make progress even when a machine has failed. Such systems are found frequently in high-reliability and -availability applications such as aviation, where computer systems are relied on for controlling machinery with strict timing requirements. Failed safety-critical redundancy engineering has seen some infamous examples recently, with deadly Boeing 737-Max incidents prompting the introduction of new laws for flight control computer error resilience~\cite{boeing-requirements}\todo{better citation}. Without a common notion of time, it would not be possible for resilient systems to judge internally missed deadlines correctly, thus preventing the system from providing proper error-detection and correction, voiding the fault-tolerance it was designed for.

However, time is not only critical in fault-tolerant systems, it pervades all distributed systems. High-performance and datacenter computing are areas large amounts of resources are being spent on maximizing hardware utilization by reducing I/O or communications bottlenecks~\cite{hpc-understanding-bottlenecks, hpc-solving-io-bottleneck, hpc-diagnosing-io-bottlenecks}, and a common notion of time across systems and components is both essential to quantifying the problem using profiling and mitigating it by optimizing synchronization. The better the time source, the easier it becomes to perform efficient handovers by precise scheduling, thus improving overall performance and resource consumption.
This technique also transfers to edge computing, where scheduling computation and communication to efficiently manage load can conserve usage of scarce resources, such as power or connectivity, allowing applications to achieve more with less hardware.

Clearly, having some sort of clock synchronization is essential in almost all aspects of computing, and the range of accuracies required can be rather large. This makes it necessary to examine what our systems are capable of and what sort of reliability guarantees they can provide for our algorithms to work with. One area where time-synchronization is desirable is industrial and embedded computing/IoT. Deployments in this area are often characterized by dependability and redundancy requirements, a general necessity to conserve all types of resources to reduce costs, and their relative isolation regarding connectivity. Good timekeeping allows a reduction in the amount of comparatively resource-intensive manual synchronization required, which directly leads to cost savings, however a high level of trust in the clock is needed to ensure ordering correctness. Across distributed embedded systems, we can use local network time synchronization to achieve this, however the question of accuracy and dependability under adverse conditions is open.

%\todo{Need a part here on what we are actually doing.}
%\todo{Dependable embedded systems.}